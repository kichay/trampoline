#!/bin/sh

# Paths
build=$(mktemp -d)
busybox=/bin/busybox
modules=$(dirname $0)/etc/modules

# Prepare init
mkdir -p \
    $build \
    $build/bin \
    $build/dev \
    $build/proc \
    $build/var \
    $build/etc \
    $build/newroot
tail $0 -n 52 > $build/init
chmod 755 $build/init
cp -L $busybox $build/bin/busybox
cp -L $modules $build/etc/modules

# Prepare modules (TODO: fix stderr)
(
    awk -F "#" '{
        if ($1 != "")
            system("busybox modinfo " gensub("^([^ |	]*).*", "\\1", "g", $1) " -F depends");
    }' $modules | awk '{
        if ($1 != "") {
            gsub(/,/, "\n");
            system("busybox modinfo -F filename " $0);
        }
    }';
    awk -F "#" '{
        if ($1 != "")
            system("busybox modinfo " gensub("^([^ |	]*).*", "\\1", "g", $1) " -F filename");
    }' $modules
) | sort -u | awk -v build=$build '{
    system("mkdir -p " build $1);
    system("rm -rf " build $1);
    system("cp " $1 " " build $1);
}'

# Build
(cd $build; find *) | cpio -H newc -R 0:0 -D $build -o > initramfs.newc

# Clean
rm -rf $build

exit 0

#!/bin/busybox sh

# Install busybox
/bin/busybox --install -s /bin
export PATH=/bin

# Pseudo filesystems
mountpoint -q /dev || mount -t devtmpfs devtmpfs /dev
mountpoint -q /proc || mount -t proc proc /proc

# Root arguments
for arg in \
    root \
    root_mount_timeout \
    root_mount_tick \
    root_init
do
    eval $(grep -o -w "$arg=[^ ]*" /proc/cmdline)
done

# Mount command
root_mount_command="mount $root /newroot"
grep -q -w "ro" /proc/cmdline && root_mount_command="$root_mount_command -o ro"

# Empty root exception
if [[ -z $root ]]; then
    echo "initrd: could not parse root argument"
    echo "cmdline: $(cat /proc/cmdline)"
    exit 1
fi

# Defaults
[[ -z $root_mount_timeout ]] && root_mount_timeout=15
[[ -z $root_mount_tick ]] && root_mount_tick=0.5
[[ -z $root_init ]] && root_init='/bin/init'

# Modprobe foreach
awk -F "#" '{
    if($1 != "")
        system("modprobe "$1);
}' /etc/modules

# Mount loop
for i in $(seq 0 $root_mount_tick $root_mount_timeout); do
    eval $root_mount_command 1>/var/mount.log 2>&1 && exec run-init /newroot $root_init
    sleep $root_mount_tick
done

# Mount error
echo "initrd: $root_mount_command (loop)"
echo "$(cat /var/mount.log) (last try)"
exit 2
